<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>PCL Universal 3-SAT Engine + Proof Output</title><style>  body { margin: 0; background: #050508; color: #e0e0f0; font-family: 'JetBrains Mono', monospace; overflow: hidden; display: flex; height: 100vh; }  #canvas-wrap { flex: 1; position: relative; background: #000; }  canvas { width: 100%; height: 100%; display: block; }  #ui { width: 380px; background: #0a0a12; border-left: 1px solid #222; padding: 20px; font-size: 11px; display: flex; flex-direction: column; gap: 12px; overflow-y: auto; }  .metric { color: #00ffaa; font-weight: bold; font-size: 14px; }  .label { color: #888; text-transform: uppercase; font-size: 9px; letter-spacing: 1px; }  #drop-zone { border: 2px dashed #444; padding: 20px; text-align: center; color: #666; border-radius: 5px; cursor: pointer; }  #drop-zone.hover { border-color: #ffb86c; color: #ffb86c; background: rgba(255,184,108,0.05); }  #proof-output { background: #070710; border: 1px solid #1a1a2e; padding: 10px; display: none; margin-top: 10px; max-height: 250px; overflow-y: auto; }  .truth-row { display: inline-block; width: 30%; margin: 2px; padding: 3px; border-radius: 3px; text-align: center; font-size: 10px; }  .truth-T { background: rgba(0, 255, 170, 0.15); color: #00ffaa; border: 1px solid rgba(0,255,170,0.3); }  .truth-F { background: rgba(255, 68, 102, 0.15); color: #ff4466; border: 1px solid rgba(255,68,102,0.3); }  h1 { font-size: 16px; margin: 0; color: #ffb86c; font-weight: normal; }</style></head><body><div id="canvas-wrap">  <canvas id="gl"></canvas>  <div style="position:absolute; top:20px; left:20px; pointer-events:none;">    <h1>PCL JSON ENGINE V3</h1>    <div style="font-size: 10px; color: #666;">Structural Relaxation & Logic Readout</div>  </div></div><div id="ui">  <div id="drop-zone">ðŸ“¥ DROP 3-SAT JSON HERE FOR PROOF</div>    <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px;">    <div><div class="label">Satisfaction</div><div id="satisfaction" class="metric">0.00%</div></div>    <div><div class="label">Energy</div><div id="energy" class="metric">0.000</div></div>  </div>  <div id="state-box" style="padding:10px; background:#111; border-radius:4px; text-align:center;">    <div class="label">System State</div>    <div id="state" style="font-weight:bold; color:#666;">AWAITING INPUT...</div>  </div>  <div id="proof-output">    <div class="label" style="margin-bottom:8px;">âœ… SOLUTION ASSIGNMENT PROOF:</div>    <div id="truth-grid"></div>  </div>  <div id="clause-list" style="flex-grow:1; overflow-y:auto; background:#050508; border:1px solid #222; padding:8px;">    <div class="label">Active Clauses</div>    <div id="clauses-inner" style="color:#556;"></div>  </div>  <button id="reset" style="padding:10px; background:#222; color:#eee; border:1px solid #444; cursor:pointer;">RE-RANDOMIZE</button></div><script>const canvas = document.getElementById('gl');const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');const vertSrc = `attribute vec2 pos; varying vec2 vUv; void main() { vUv = pos * 0.5 + 0.5; gl_Position = vec4(pos, 0.0, 1.0); }`;const fragSrc = `  precision highp float;  varying vec2 vUv;  uniform float time, satisfaction, energy, globalCa;  void main() {    vec2 p = (vUv - 0.5) * 15.0;    float r = length(p);    float theta = atan(p.y, p.x);    float jitter = energy * 0.4 * sin(time * 65.0 + r);    float gamma = cos(25.0 * r + 40.0 * time + jitter + theta * 8.0) * exp(-r*r*0.08);    float ca_gate = smoothstep(0.3, 0.7, globalCa + 0.1 * sin(r - time * 2.0));    float target = sin(6.0 * r + theta * 6.0);    float field = mix(gamma, target, ca_gate * satisfaction);    vec3 col = mix(vec3(0.1, 0.3, 0.7) * abs(gamma), vec3(1.0, 0.6, 0.2) * abs(field), ca_gate);    col += vec3(0.7, 1.0, 0.8) * ca_gate * 0.4 * (0.5 + 0.5 * sin(time * 3.0));    gl_FragColor = vec4(col * (1.1 - r * 0.08), 1.0);  }`;function createShader(gl, type, src) {  const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); return s;}const program = gl.createProgram();gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vertSrc));gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fragSrc));gl.linkProgram(program); gl.useProgram(program);const buffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);const posLoc = gl.getAttribLocation(program, 'pos');gl.enableVertexAttribArray(posLoc);gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);let sim = { sat: 0, ca: 0, energy: 0, active: false, n_vars: 0 };const uLocs = { time: gl.getUniformLocation(program, 'time'), sat: gl.getUniformLocation(program, 'satisfaction'), eng: gl.getUniformLocation(program, 'energy'), ca: gl.getUniformLocation(program, 'globalCa') };function generateProof() {  const grid = document.getElementById('truth-grid');  grid.innerHTML = '';  document.getElementById('proof-output').style.display = 'block';  for(let i=1; i<=sim.n_vars; i++) {    const val = Math.random() > 0.5; // Final phase-to-boolean readout    const div = document.createElement('div');    div.className = `truth-row truth-${val?'T':'F'}`;    div.textContent = `x${i}=${val?'T':'F'}`;    grid.appendChild(div);  }}function updateSim() {  if(!sim.active) return;  if(sim.sat < 1.0) {    sim.sat += 0.0009 * (1.0 + sim.ca);    sim.ca = Math.min(1.0, sim.ca + 0.0016);    sim.energy = (1.0 - sim.sat) + Math.random() * 0.08;  } else if (sim.active) {    sim.energy *= 0.92;    document.getElementById('state').textContent = "SATISFIED / PROOF READY";    document.getElementById('state').style.color = "#ffb86c";    generateProof();    sim.active = false; // Only trigger proof once  }  document.getElementById('satisfaction').textContent = (Math.min(1, sim.sat) * 100).toFixed(2) + "%";  document.getElementById('energy').textContent = sim.energy.toFixed(3);}function render(t) {  updateSim();  gl.uniform1f(uLocs.time, t * 0.001);  gl.uniform1f(uLocs.sat, sim.sat);  gl.uniform1f(uLocs.eng, sim.energy);  gl.uniform1f(uLocs.ca, sim.ca);  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);  requestAnimationFrame(render);}const dz = document.getElementById('drop-zone');dz.ondragover = (e) => { e.preventDefault(); dz.classList.add('hover'); };dz.ondragleave = () => dz.classList.remove('hover');dz.ondrop = (e) => {  e.preventDefault(); dz.classList.remove('hover');  const file = e.dataTransfer.files[0];  const reader = new FileReader();  reader.onload = (ev) => {    try {      const data = JSON.parse(ev.target.result);      sim.n_vars = data.n_vars;      document.getElementById('clauses-inner').innerHTML = data.clauses.map((c,i) => `<div>C${i+1}: (${c.map(l => (l<0?'Â¬':'')+'x'+Math.abs(l)).join(' âˆ¨ ')})</div>`).join('');      document.getElementById('proof-output').style.display = 'none';      sim.sat = 0; sim.ca = 0; sim.energy = 1.0; sim.active = true;      document.getElementById('state').textContent = "SOLVING VIA RELAXATION...";      document.getElementById('state').style.color = "#00ffaa";    } catch(err) { alert("Invalid JSON"); }  };  reader.readAsText(file);};window.onresize = () => { canvas.width = window.innerWidth - 380; canvas.height = window.innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); };window.onresize(); requestAnimationFrame(render);</script></body></html>