<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>PCL Universal 3-SAT Engine â€” REAL LOGIC</title><style>  body { margin: 0; background: #050508; color: #e0e0f0; font-family: 'JetBrains Mono', monospace; overflow: hidden; display: flex; height: 100vh; }  #canvas-wrap { flex: 1; position: relative; background: #000; }  canvas { width: 100%; height: 100%; display: block; }  #ui { width: 380px; background: #0a0a12; border-left: 1px solid #222; padding: 20px; font-size: 11px; display: flex; flex-direction: column; gap: 12px; overflow-y: auto; }  .metric { color: #00ffaa; font-weight: bold; font-size: 14px; }  .label { color: #888; text-transform: uppercase; font-size: 9px; letter-spacing: 1px; }  #drop-zone { border: 2px dashed #444; padding: 20px; text-align: center; color: #666; border-radius: 5px; cursor: pointer; }  #drop-zone.hover { border-color: #ffb86c; color: #ffb86c; background: rgba(255,184,108,0.05); }  #proof-output { background: #070710; border: 1px solid #1a1a2e; padding: 10px; display: none; margin-top: 10px; }  .truth-grid { display: flex; flex-wrap: wrap; gap: 4px; }  .truth-row { padding: 3px 6px; border-radius: 3px; font-size: 10px; border: 1px solid transparent; }  .truth-T { background: rgba(0, 255, 170, 0.1); color: #00ffaa; border-color: rgba(0,255,170,0.3); }  .truth-F { background: rgba(255, 68, 102, 0.1); color: #ff4466; border-color: rgba(255,68,102,0.3); }  h1 { font-size: 16px; margin: 0; color: #ffb86c; font-weight: normal; }</style></head><body><div id="canvas-wrap"><canvas id="gl"></canvas></div><div id="ui">  <h1>PCL ENGINE (REAL LOGIC)</h1>  <div id="drop-zone">ðŸ“¥ DROP 3-SAT JSON HERE</div>    <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px;">    <div><div class="label">Satisfaction</div><div id="satisfaction" class="metric">0.00%</div></div>    <div><div class="label">Energy (Stress)</div><div id="energy" class="metric">0.000</div></div>  </div>  <div id="state-box" style="padding:10px; background:#111; border-radius:4px; text-align:center;">    <div class="label">Engine State</div>    <div id="state" style="font-weight:bold; color:#666;">AWAITING PHYSICS...</div>  </div>  <div id="proof-output">    <div class="label" style="margin-bottom:8px;">âœ… VERIFIED ASSIGNMENT:</div>    <div id="truth-grid" class="truth-grid"></div>  </div>  <div id="clause-list" style="flex-grow:1; overflow-y:auto; background:#050508; border:1px solid #222; padding:8px;">    <div class="label">Clause Constraints</div>    <div id="clauses-inner" style="color:#556; line-height:1.4;"></div>  </div>  <button id="reset" style="padding:10px; background:#222; color:#eee; border:1px solid #444; cursor:pointer;">RESET PHASES</button></div><script>const canvas = document.getElementById('gl');const gl = canvas.getContext('webgl');// Shader logic remains for visualization, but inputs are now realconst vertSrc = `attribute vec2 pos; varying vec2 vUv; void main() { vUv = pos * 0.5 + 0.5; gl_Position = vec4(pos, 0.0, 1.0); }`;const fragSrc = `  precision highp float;  varying vec2 vUv;  uniform float time, satisfaction, energy, globalCa;  void main() {    vec2 p = (vUv - 0.5) * 15.0;    float r = length(p); float theta = atan(p.y, p.x);    float jitter = energy * 0.5 * sin(time * 80.0);    float gamma = cos(20.0 * r + 30.0 * time + jitter + theta * 8.0) * exp(-r*r*0.07);    float ca_gate = smoothstep(0.3, 0.7, globalCa + 0.1 * sin(r - time * 2.0));    float field = mix(gamma, sin(5.0 * r + theta * 6.0), ca_gate * satisfaction);    vec3 col = mix(vec3(0.1, 0.2, 0.5) * abs(gamma), vec3(1.0, 0.7, 0.2) * abs(field), ca_gate);    gl_FragColor = vec4(col * (1.1 - r * 0.08), 1.0);  }`;function createShader(gl, type, src) {  const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); return s;}const program = gl.createProgram();gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vertSrc));gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fragSrc));gl.linkProgram(program); gl.useProgram(program);const buffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);const posLoc = gl.getAttribLocation(program, 'pos');gl.enableVertexAttribArray(posLoc);gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);// --- REAL SOLVER STATE ---let solver = {  active: false,  phases: [],  clauses: [],  n_vars: 0,  sat: 0,  ca: 0,  drive: 18.5,  dt: 0.04};function runPhysics() {  if (!solver.active) return;    let dphi = new Array(solver.n_vars).fill(0);  let satisfied = 0;  solver.clauses.forEach(clause => {    // Check truth: cos(phi) > 0 is True    let isSat = clause.some(lit => {      let p = solver.phases[Math.abs(lit)-1];      return lit > 0 ? Math.cos(p) > 0 : Math.cos(p) < 0;    });    if (isSat) {      satisfied++;    } else {      // Unsatisfied clauses apply TORQUE      let lit = clause[Math.floor(Math.random() * clause.length)];      let idx = Math.abs(lit) - 1;      let target = lit > 0 ? 0 : Math.PI;      dphi[idx] += solver.drive * Math.sin(target - solver.phases[idx]);    }  });  solver.sat = satisfied / solver.clauses.length;  solver.ca = Math.min(1.0, solver.ca + 0.001); // Calcium grows with simulation time  // Integrate phases with noise  for (let i = 0; i < solver.n_vars; i++) {    solver.phases[i] += dphi[i] * solver.dt + (Math.random() - 0.5) * 0.15;    solver.phases[i] %= (Math.PI * 2);  }  if (solver.sat >= 1.0) {    document.getElementById('state').textContent = "RESONANCE ACHIEVED";    document.getElementById('state').style.color = "#ffb86c";    renderProof();    solver.active = false;  }}function renderProof() {  const grid = document.getElementById('truth-grid');  grid.innerHTML = '';  document.getElementById('proof-output').style.display = 'block';  solver.phases.forEach((p, i) => {    const val = Math.cos(p) > 0;    const div = document.createElement('div');    div.className = `truth-row truth-${val?'T':'F'}`;    div.textContent = `x${i+1}=${val?'T':'F'}`;    grid.appendChild(div);  });}const uLocs = { time: gl.getUniformLocation(program, 'time'), sat: gl.getUniformLocation(program, 'satisfaction'), eng: gl.getUniformLocation(program, 'energy'), ca: gl.getUniformLocation(program, 'globalCa') };function render(t) {  runPhysics();  document.getElementById('satisfaction').textContent = (solver.sat * 100).toFixed(2) + "%";  document.getElementById('energy').textContent = (1.0 - solver.sat).toFixed(3);    gl.uniform1f(uLocs.time, t * 0.001);  gl.uniform1f(uLocs.sat, solver.sat);  gl.uniform1f(uLocs.eng, 1.0 - solver.sat);  gl.uniform1f(uLocs.ca, solver.ca);  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);  requestAnimationFrame(render);}const dz = document.getElementById('drop-zone');dz.ondrop = (e) => {  e.preventDefault();  const file = e.dataTransfer.files[0];  const reader = new FileReader();  reader.onload = (ev) => {    const data = JSON.parse(ev.target.result);    solver.n_vars = data.n_vars;    solver.clauses = data.clauses;    solver.phases = Array.from({length: data.n_vars}, () => Math.random() * Math.PI * 2);    solver.ca = 0; solver.sat = 0; solver.active = true;    document.getElementById('proof-output').style.display = 'none';    document.getElementById('state').textContent = "RELAXING PHASES...";    document.getElementById('clauses-inner').innerHTML = data.clauses.map(c => `<div>(${c.join(',')})</div>`).join('');  };  reader.readAsText(file);};dz.ondragover = (e) => e.preventDefault();document.getElementById('reset').onclick = () => {  solver.phases = solver.phases.map(() => Math.random() * Math.PI * 2);  solver.active = true; solver.sat = 0;};window.onresize = () => { canvas.width = window.innerWidth - 380; canvas.height = window.innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); };window.onresize(); requestAnimationFrame(render);</script></body></html>